---
alwaysApply: true
---

Adhere to the following naming conventions for an idiomatic Effect.ts codebase.

### 1. Domain Interfaces

* **Name** as a plain noun reflecting the core capability or role (e.g. `Email`, `Auth`, `Database`).
* **Do not** add a trailing "Service" unless "Service" is literally part of your ubiquitous language (e.g. a wrapped third-party `PaymentService`).

```ts
export interface Email {
  send(to: string, body: string): Effect<never, EmailError, void>
}
```

### 2. Tags

* **Always** suffix with `Tag` (e.g. `EmailTag`, `DatabaseTag`).
* Use as your DI key: `Tag<YourInterface>("YourInterface")`.
* The string identifier should **exactly** match the interface name.

```ts
export const DatabaseTag = Tag<Database>("Database")
```

### 3. Live Implementations

* **Suffix** with `Live` (never `Impl`), e.g. `EmailLive`, `DatabaseLive`.
* Expose via a layer named `<Interface>LiveLayer`.

```ts
export const EmailLiveLayer = Layer.succeed(EmailTag, new SmtpEmail())
```

### 4. Layers

* **Suffix** with `Layer`, e.g. `ConfigLayer`, `EmailLiveLayer`.
* Bundle related services and configs into a single injectable module.
* Show dependencies explicitly when composing layers.

```ts
export const AppLayer = ConfigLayer.pipe(
  Layer.merge(DatabaseLiveLayer),
  Layer.merge(EmailLiveLayer)
)

// Or with dependencies:
export const EmailLiveLayer = Layer.effect(
  EmailTag,
  Effect.gen(function* (_) {
    const config = yield* _(SmtpConfigTag)
    return new SmtpEmail(config)
  })
).pipe(Layer.provide(ConfigLayer))
```

### 5. Config Objects

* **Define** an interface named `…Config` (e.g. `SmtpConfig`, `DbConfig`).
* **Create** a matching tag: `…ConfigTag`.
* **Optionally** group multiple config tags into a shared `ConfigLayer`.

```ts
export interface DbConfig { url: string }
export const DbConfigTag = Tag<DbConfig>("DbConfig")

export const ConfigLayer = Layer.succeed(DbConfigTag, { url: ENV.DB_URL })
```

### 6. Error Types

* **Model** domain errors as union types or custom classes.
* **Suffix** with `Error` (e.g. `EmailError`, `DbError`).
* **Group** related variants in a namespace if needed.

```ts
export class EmailError extends Error { /* ... */ }
export type DbError = ConnectionError | QueryError
```

### 7. Qualifiers

* For multiple implementations of the same interface, use distinct tags named for their role.

```ts
export const PrimaryDbTag = Tag<Database>("PrimaryDatabase")
export const ReplicaDbTag = Tag<Database>("ReplicaDatabase")
```

### 8. Factory Functions

* **Prefix** with `make…` or `create…` for helpers that build scoped or complex resources.

```ts
export function makePool(config: DbConfig): Effect<Scope, never, Pool> { … }
```

### 9. Test/Mock Layers

* **Suffix** with `MockLayer` or `TestLayer` (to mirror `LiveLayer` naming).
* Provide in-memory or mock implementations for testing.

```ts
export const UserRepoMockLayer = Layer.succeed(UserRepoTag, new InMemoryUserRepo())
```

### 10. Streams, Queues, Hubs

* **Suffix** with the resource type (`…Stream`, `…Queue`, `…Hub`).
* **Combine** with tags: `…StreamTag`, etc.

```ts
export const LogEventStreamTag = Tag<Stream<LogEvent>>("LogEventStream")
```

### 11. Schemas and Validation

* **Name** schemas after the type they validate, suffixed with `Schema`.
* **Derive** types from schemas using `Schema.Type`.

```ts
export const UserSchema = Schema.Struct({
  id: Schema.String,
  email: Schema.String,
  createdAt: Schema.Date
})

export type User = Schema.Schema.Type<typeof UserSchema>
```

### 12. Request/Response Types

* **Suffix** with `Request` or `Response` for complex method parameters.
* **Group** related types near their service interface.

```ts
export interface SendEmailRequest {
  to: string
  subject: string
  body: string
  attachments?: Array<Attachment>
}

export interface Email {
  send(request: SendEmailRequest): Effect<never, EmailError, void>
}
```

### 13. Branded Types

* **Use** branded types for domain modeling to ensure type safety.
* **Export** both the type and its constructor/validator.

```ts
export type UserId = string & Brand.Brand<"UserId">
export const UserId = Brand.nominal<UserId>()

export type Email = string & Brand.Brand<"Email">
export const Email = Brand.refined<Email>(
  (s) => s.includes("@"),
  (s) => Brand.error(`Invalid email: ${s}`)
)
```

### 14. Ports (Hexagonal Architecture)

* **Suffix** port interfaces with `Port` to distinguish from domain interfaces.
* **Place** in `ports/` directory to separate from core domain.
* **Use** the same Tag naming convention with the full interface name.

```ts
// ports/user-repository-port.ts
export interface UserRepositoryPort {
  findById(id: UserId): Effect<never, NotFoundError, User>
  save(user: User): Effect<never, DatabaseError, void>
}

export const UserRepositoryPortTag = Tag<UserRepositoryPort>("UserRepositoryPort")

// ports/email-port.ts
export interface EmailPort {
  send(request: SendEmailRequest): Effect<never, EmailError, void>
}

export const EmailPortTag = Tag<EmailPort>("EmailPort")
```

### 15. Adapters (Hexagonal Architecture)

* **Place** adapter implementations in `adapters/` directory, organized by infrastructure type.
* **Name** adapters descriptively based on the technology they use.
* **Follow** the `Live` suffix pattern for layer exports.

```ts
// adapters/postgres/user-repository-adapter.ts
export class PostgresUserRepository implements UserRepositoryPort {
  // implementation
}

export const UserRepositoryPortLiveLayer = Layer.effect(
  UserRepositoryPortTag,
  Effect.gen(function* (_) {
    const db = yield* _(DatabaseTag)
    return new PostgresUserRepository(db)
  })
)

// adapters/smtp/email-adapter.ts
export class SmtpEmailAdapter implements EmailPort {
  // implementation
}

export const EmailPortLiveLayer = Layer.succeed(
  EmailPortTag,
  new SmtpEmailAdapter()
)
```

#### Additional Tips

* **Method Names**: Use lower-camelCase (`sendEmail`, `fetchUser`, etc.).

* **Avoid** `I`-prefix on interfaces; plain nouns are preferred.

* **Helper** for repetitive layer wiring:

  ```ts
  export const makeLayer = <T>(tag: Tag.Tag<T>, impl: T) =>
    Layer.succeed(tag, impl)
  ```

* **Composed App Layer**: Re-export a "stack" when many small layers always wire together:

  ```ts
  export const AppLayer = Layer.mergeAll(
    ConfigLayer,
    DatabaseLiveLayer,
    EmailLiveLayer,
    LoggerLiveLayer
  )
  ```

* **Port vs Domain Interface**: Use ports for infrastructure boundaries (database, external APIs, file system). Keep domain interfaces for core business logic that might be implemented within the domain itself.

With these conventions—using **Live** across the board and **Port** for hexagonal boundaries—your Effect.ts codebase will stay clear, consistent, and idiomatic.
